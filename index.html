<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aurora Prelude Optimizer</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Modern CSS Reset and Variables */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    :root {
      /* Professional color palette */
      --bg: #f8fafc;
      --bg-secondary: #f1f5f9;
      --fg: #1e293b;
      --fg-secondary: #64748b;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --accent-subtle: #eff6ff;
      --card-bg: #ffffff;
      --border: #e2e8f0;
      --success: #10b981;
      --success-subtle: #ecfdf5;
      --warning: #f59e0b;
      --warning-subtle: #fffbeb;
      --danger: #ef4444;
      --danger-subtle: #fef2f2;
      --info: #0ea5e9;
      --info-subtle: #f0f9ff;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
      --radius-sm: 6px;
      --radius: 10px;
      --radius-lg: 16px;
      --transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      --max-width: 1080px;
      --tooltip-bg: rgba(15, 23, 42, 0.9);
      --glass-bg: rgba(255, 255, 255, 0.7);
      --glass-border: rgba(255, 255, 255, 0.5);
    }

    body.dark {
      --bg: #0f172a;
      --bg-secondary: #1e293b;
      --fg: #f1f5f9;
      --fg-secondary: #94a3b8;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --accent-subtle: #1e3a8a;
      --card-bg: #1e293b;
      --border: #334155;
      --success: #10b981;
      --success-subtle: #064e3b;
      --warning: #f59e0b;
      --warning-subtle: #78350f;
      --danger: #ef4444;
      --danger-subtle: #7f1d1d;
      --info: #0ea5e9;
      --info-subtle: #0c4a6e;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.25);
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4);
      --tooltip-bg: rgba(241, 245, 249, 0.8);
      --glass-bg: rgba(15, 23, 42, 0.7);
      --glass-border: rgba(30, 41, 59, 0.8);
    }

    /* Typography and Base Styles */
    body {
      font-family: 'Outfit', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      transition: background 0.3s, color 0.3s;
      line-height: 1.6;
      letter-spacing: -0.01em;
    }

    h1, h2, h3, h4 {
      margin: 0;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      background: linear-gradient(120deg, var(--accent), #8b5cf6);
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
    }

    h3 {
      font-size: 1.25rem;
      margin: 1.5rem 0 1rem;
      color: var(--fg);
      position: relative;
      display: inline-block;
    }
    
    h3::after {
      content: "";
      position: absolute;
      bottom: -4px;
      left: 0;
      width: 2.5rem;
      height: 3px;
      background: var(--accent);
      border-radius: 3px;
    }

    p {
      color: var(--fg-secondary);
      margin: 0.5rem 0 1rem;
    }

    /* Layout Components */
    .container {
      max-width: var(--max-width);
      margin: 0 auto;
      padding: 1.5rem;
    }

    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
      gap: 1rem;
      position: relative;
      padding: 1.5rem;
      border-radius: var(--radius);
      background: var(--card-bg);
      box-shadow: var(--shadow);
      border-bottom: 3px solid var(--accent);
    }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius);
      padding: 1.75rem 2rem;
      box-shadow: var(--shadow);
      margin-bottom: 1.75rem;
      transition: transform var(--transition), box-shadow var(--transition);
      border-left: 3px solid var(--accent);
      border-top: 1px solid var(--border);
      border-right: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
    }

    .card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    .recipe-icons {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 16px;
      margin: 1.5rem 0;
    }

    .recipe-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0.75rem;
      border-radius: var(--radius-sm);
      background: var(--bg-secondary);
      transition: all var(--transition);
      cursor: help;
      text-align: center;
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
    }

    .recipe-icon::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--accent);
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
    }

    .recipe-icon:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }

    .recipe-icon:hover::before {
      transform: scaleX(1);
    }

    .recipe-icon-count {
      font-size: 1.5rem;
      font-weight: 700;
      margin-top: 0.5rem;
      color: var(--accent);
    }

    .recipe-icon-emoji {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      transition: transform 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      justify-self: center;
      width: 3rem;
      height: 3rem;
      border-radius: 50%;
      background: var(--accent-subtle);
    }

    .recipe-icon:hover .recipe-icon-emoji {
      transform: scale(1.1);
    }

    /* Tables */
    table {
      border-collapse: separate;
      border-spacing: 0;
      width: 100%;
      margin: 1.25rem 0;
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      font-size: 0.95rem;
    }

    th, td {
      padding: 0.85rem 1.25rem;
      text-align: center;
      border-bottom: 1px solid var(--border);
      border-right: 1px solid var(--border);
    }

    th {
      background: var(--accent-subtle);
      color: var(--accent);
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 0.05em;
    }

    tr:last-child td {
      border-bottom: none;
    }

    td:last-child, th:last-child {
      border-right: none;
    }

    tr:nth-child(even) {
      background: var(--bg-secondary);
    }

    tr:hover {
      background-color: var(--accent-subtle);
    }

    td:first-child, th:first-child {
      text-align: left;
      border-left: none;
    }

    /* Input-specific styling */
    .input-group {
      display: flex;
      align-items: center;
      gap: 10px;
      position: relative;
    }

    input[type=number] {
      width: 100px;
      padding: 0.625rem 1rem;
      text-align: right;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--card-bg);
      color: var(--fg);
      transition: all var(--transition);
      font-size: 0.95rem;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
    }

    input[type=number]:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
    }

    .increment-buttons {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .increment-button {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--fg-secondary);
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 14px;
      padding: 0;
      line-height: 1;
      transition: all var(--transition);
    }

    .increment-button:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* Controls and Buttons */
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 1.5rem 0;
      justify-content: center;
    }

    .button {
      cursor: pointer;
      padding: 0.65rem 1.25rem;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 0.95rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all var(--transition);
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }

    .button::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      opacity: 0;
      transition: opacity var(--transition);
    }

    .button:hover::after {
      opacity: 1;
    }

    .button:active {
      transform: translateY(1px);
    }

    .button-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      color: white;
    }

    .button-primary:hover {
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35);
    }

    .button-secondary {
      background: var(--bg-secondary);
      color: var(--fg);
      border: 1px solid var(--border);
    }

    .button-secondary:hover {
      background: var(--accent-subtle);
      color: var(--accent);
      border-color: var(--accent);
    }

    .button-outline {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--fg);
    }

    .button-outline:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accent-subtle);
    }

    .button-icon {
      font-size: 0.95rem;
    }

    /* Excel Paste UI */
    .paste-area {
      display: none;
      margin-top: 1rem;
      animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow-lg);
      border-left: 3px solid var(--accent);
    }

    .paste-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
    }

    textarea {
      width: 100%;
      height: 140px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg-secondary);
      color: var(--fg);
      font-family: 'JetBrains Mono', monospace;
      padding: 1rem;
      margin-bottom: 1.25rem;
      resize: vertical;
      transition: all var(--transition);
      font-size: 0.9rem;
      line-height: 1.5;
    }

    textarea:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
      background: var(--card-bg);
    }
    
    textarea::placeholder {
      color: var(--fg-secondary);
      opacity: 0.6;
    }

    /* Processing and Animations */
    #processing {
      display: none;
      text-align: center;
      padding: 1.5rem;
      margin: 1.5rem 0;
      color: var(--accent);
      animation: pulse 1.5s infinite;
      background: var(--accent-subtle);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      font-weight: 500;
    }

    .toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      padding: 1rem 1.5rem;
      border-radius: var(--radius-sm);
      color: white;
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s, transform 0.3s;
      max-width: 350px;
      display: flex;
      align-items: center;
      gap: 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .toast.success {
      background: linear-gradient(to right, var(--success), #059669);
      border-left: 4px solid var(--success);
    }
    
    .toast.error {
      background: linear-gradient(to right, var(--danger), #b91c1c);
      border-left: 4px solid var(--danger);
    }
    
    .toast.warning {
      background: linear-gradient(to right, var(--warning), #d97706);
      border-left: 4px solid var(--warning);
      color: #1f2937;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    
    .toast-icon {
      font-size: 1.25rem;
    }

    /* Utility and Animation Styles */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      margin: -1px;
      padding: 0;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .text-center { text-align: center; }
    .text-success { color: var(--success); }
    .text-warning { color: var(--warning); }
    .text-danger { color: var(--danger); }
    .bg-success { background-color: var(--success); }
    .bg-warning { background-color: var(--warning); }
    .bg-danger { background-color: var(--danger); }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin: 1.5rem 0;
    }

    .stat-card {
      background: var(--bg-secondary);
      border-radius: var(--radius);
      padding: 1.5rem;
      text-align: center;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
      transition: transform var(--transition), box-shadow var(--transition);
    }
    
    .stat-card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: var(--accent);
    }
    
    .stat-card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow);
    }

    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(120deg, var(--accent), #8b5cf6);
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
      margin: 0.75rem 0;
      line-height: 1;
    }

    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltip-text {
      visibility: hidden;
      background-color: var(--tooltip-bg);
      color: white;
      text-align: center;
      border-radius: var(--radius-sm);
      padding: 0.65rem 1rem;
      position: absolute;
      z-index: 10;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%) translateY(10px);
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      white-space: nowrap;
      box-shadow: var(--shadow);
      font-weight: 500;
      font-size: 0.85rem;
      pointer-events: none;
    }
    
    .tooltip .tooltip-text::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -6px;
      border-width: 6px;
      border-style: solid;
      border-color: var(--tooltip-bg) transparent transparent transparent;
    }

    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .leftover-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      position: relative;
      top: 1px;
    }

    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes scaleIn {
      from { transform: scale(0.95); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .spinner {
      display: inline-block;
      width: 28px;
      height: 28px;
      border: 3px solid rgba(59, 130, 246, 0.2);
      border-radius: 50%;
      border-top-color: var(--accent);
      animation: spin 0.8s infinite ease-in-out;
      margin-right: 12px;
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.2);
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
      .container {
        padding: 0.75rem;
      }

      .card {
        padding: 1.25rem;
        margin-bottom: 1.25rem;
      }

      .topbar {
        flex-direction: column;
        text-align: center;
        padding: 1.25rem;
        margin-bottom: 1.25rem;
      }

      table {
        font-size: 0.875rem;
      }

      th, td {
        padding: 0.625rem 0.75rem;
      }

      .recipe-icons {
        grid-template-columns: repeat(auto-fill, minmax(85px, 1fr));
      }
      
      .button-group {
        flex-direction: column;
      }
      
      .button {
        width: 100%;
        justify-content: center;
      }
      
      h1 {
        font-size: 1.75rem;
      }
      
      .stats {
        grid-template-columns: 1fr;
      }
    }
    
    /* File input styling */
    input[type="file"] {
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      position: absolute;
      z-index: -1;
    }
    
    .file-input-label {
      cursor: pointer;
      padding: 0.65rem 1.25rem;
      border-radius: var(--radius-sm);
      background: var(--bg-secondary);
      color: var(--fg);
      border: 1px solid var(--border);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all var(--transition);
      font-size: 0.95rem;
      font-weight: 500;
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
    }
    
    .file-input-label::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      opacity: 0;
      transition: opacity var(--transition);
    }
    
    .file-input-label:hover::after {
      opacity: 1;
    }
    
    .file-input-label:hover {
      background: var(--accent-subtle);
      color: var(--accent);
      border-color: var(--accent);
    }
    
    /* Results animation */
    #results:not(:empty) {
      animation: scaleIn 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Quick preset buttons */
    .preset-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 1rem 0;
    }
    
    .preset-btn {
      font-size: 0.85rem;
      padding: 0.5rem 0.875rem;
      border-radius: var(--radius-sm);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      cursor: pointer;
      transition: all var(--transition);
      color: var(--fg-secondary);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .preset-btn:hover {
      background: var(--accent-subtle);
      color: var(--accent);
      border-color: var(--accent);
    }
    
    /* Auto-save indicator */
    .auto-save-indicator {
      position: fixed;
      bottom: 20px;
      left: 20px;
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      background: var(--success-subtle);
      color: var(--success);
      font-size: 0.75rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s, transform 0.3s;
      z-index: 999;
    }
    
    .auto-save-indicator.show {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Modal Dialog */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    .modal.show {
      display: flex;
      animation: fadeIn 0.3s forwards;
    }
    
    .modal-content {
      background-color: var(--card-bg);
      border-radius: var(--radius);
      width: 90%;
      max-width: 600px;
      box-shadow: var(--shadow-lg);
      max-height: 90vh;
      overflow-y: auto;
      transform: scale(0.9);
      opacity: 0;
      animation: scaleIn 0.3s forwards;
      border-left: 3px solid var(--accent);
    }
    
    .modal-header {
      padding: 1.25rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .modal-body {
      padding: 1.5rem;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      color: var(--fg-secondary);
      transition: color var(--transition);
    }
    
    .modal-close:hover {
      color: var(--accent);
    }
    
    .form-group {
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .form-group label {
      font-weight: 500;
      flex-shrink: 0;
    }
    
    /* Suggestion Results Styling */
    .suggestion-card {
      background: var(--accent-subtle);
      border-radius: var(--radius);
      padding: 1.25rem;
      margin-top: 1.5rem;
      border-left: 3px solid var(--accent);
    }
    
    .suggestion-intro {
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
    }
    
    .suggestion-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .suggestion-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--card-bg);
      padding: 0.75rem 1rem;
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-sm);
    }
    
    .suggestion-amount {
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent);
      background: var(--accent-subtle);
      padding: 0.25rem 0.5rem;
      border-radius: var(--radius-sm);
    }
    
    .suggestion-actions {
      margin-top: 1rem;
      text-align: right;
    }
    
    .apply-suggestion {
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      color: white;
      border: none;
      padding: 0.65rem 1.25rem;
      border-radius: var(--radius-sm);
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      transition: all var(--transition);
      box-shadow: var(--shadow-sm);
    }
    
    .apply-suggestion:hover {
      box-shadow: var(--shadow);
      transform: translateY(-2px);
    }
    
    /* Glass morphism effects for special areas */
    .glass-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="topbar">
      <h1><i class="fas fa-cookie"></i> Aurora Prelude Optimizer</h1>
      <button id="themeToggle" class="button button-outline">
        <i class="fas fa-moon"></i> <span id="themeLabel">Dark Mode</span>
      </button>
    </div>

    <div class="card" id="ingredients-card">
      <h3><i class="fas fa-cubes"></i> Ingredient Stock</h3>
      <p>Enter your current ingredient quantities to find the optimal recipe combination.</p>
      
      <div class="preset-buttons">
        <button class="preset-btn" onclick="applyPreset('clear')">
          <i class="fas fa-eraser"></i> Clear All
        </button>
        <button class="preset-btn" onclick="applyPreset('random')">
          <i class="fas fa-dice"></i> Random Values
        </button>
        <button class="preset-btn" onclick="applyPreset('balanced')">
          <i class="fas fa-balance-scale"></i> Balanced (10 each)
        </button>
      </div>
      
      <div id="ingredients-table"></div>
    </div>

    <div class="card paste-area" id="excelCard">
      <div class="paste-header">
        <h3><i class="fas fa-paste"></i> Paste from Excel</h3>
        <button class="button button-outline" onclick="closePasteArea()">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <p>Paste your data in one of these formats:</p>
      <ol>
        <li>One number per line (matches ingredients in order)</li>
        <li>Name and value pairs (e.g. "Egg 5" or "Egg, 5")</li>
      </ol>
      <textarea id="excelPaste" placeholder="Paste numbers here, e.g.
20
15
22
...

Or ingredient value pairs like:
Egg 5
Flour 10"></textarea>
      <div class="button-group">
        <button class="button button-primary" onclick="parseExcelPaste()">
          <i class="fas fa-check"></i> Apply Paste
        </button>
      </div>
    </div>

    <div class="button-group">
      <button id="optimizeBtn" class="button button-primary" onclick="optimize()">
        <i class="fas fa-calculator"></i> Optimize Recipes
      </button>
      <button id="suggestBtn" class="button button-primary" onclick="suggestIngredients()">
        <i class="fas fa-lightbulb"></i> Suggest Ingredients
      </button>
      <button class="button button-secondary" onclick="togglePasteBox()">
        <i class="fas fa-clipboard"></i> Paste from Excel
      </button>
      <label for="importFile" class="file-input-label">
        <i class="fas fa-file-import"></i> Import
      </label>
      <input type="file" id="importFile" onchange="importData(event)" />
      <button class="button button-secondary" onclick="exportData()">
        <i class="fas fa-file-export"></i> Export
      </button>
      <button class="button button-secondary" onclick="clearData()">
        <i class="fas fa-eraser"></i> Reset All
      </button>
    </div>

    <div id="processing">
      <div class="spinner"></div>
      <span>Calculating optimal recipe combination...</span>
    </div>
    
    <div id="results"></div>
  </div>

  <div id="toast" class="toast"></div>
  <div id="autoSaveIndicator" class="auto-save-indicator"><i class="fas fa-save"></i> Auto-saving...</div>
  
  <!-- Ingredient Suggestion Modal -->
  <div id="suggestionModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3><i class="fas fa-lightbulb"></i> Ingredient Request Optimizer</h3>
        <button class="modal-close" onclick="closeModal('suggestionModal')"><i class="fas fa-times"></i></button>
      </div>
      <div class="modal-body">
        <p>How many total ingredients can you request from teammates?</p>
        <div class="form-group">
          <label for="maxIngredients">Maximum ingredients:</label>
          <input type="number" id="maxIngredients" value="50" min="1" max="1000">
        </div>
        <div class="button-group">
          <button class="button button-primary" onclick="calculateOptimalIngredientRequest()">
            <i class="fas fa-magic"></i> Calculate Best Ingredients
          </button>
        </div>
        <div id="suggestionResults"></div>
      </div>
    </div>
  </div>

  <script>
    // Recipe and Ingredient Data
    const recipes = [
      { name: "Sweet Bean Hammer", emoji: "ðŸ”¨" },
      { name: "Ice and Snow Symphony", emoji: "â„ï¸" },
      { name: "Choral Cookie", emoji: "ðŸª" },
      { name: "Piano Mousse", emoji: "ðŸŽ¹" },
      { name: "Cappuccino Aubade", emoji: "â˜•" },
      { name: "Marching Drum Cake", emoji: "ðŸ¥" }
    ];

    const ingredients = [
      "Egg", "Yeast", "Jelly Bean", "Nut", "Milk", "Jam", 
      "Sugar", "Frosting", "Cacao", "Flour", "Coffee Bean", "Marshmallow"
    ];

    const requirements = {
      "Sweet Bean Hammer": { "Egg": 1, "Yeast": 1, "Jelly Bean": 2 },
      "Ice and Snow Symphony": { "Nut": 1, "Milk": 1, "Jam": 2 },
      "Choral Cookie": { "Milk": 1, "Sugar": 1, "Frosting": 2 },
      "Piano Mousse": { "Yeast": 1, "Cacao": 2, "Flour": 1 },
      "Cappuccino Aubade": { "Nut": 1, "Sugar": 1, "Coffee Bean": 2 },
      "Marching Drum Cake": { "Egg": 1, "Flour": 1, "Marshmallow": 2 }
    };

    // DOM Elements and Initialization
    document.addEventListener('DOMContentLoaded', () => {
      renderIngredientsTable();
      loadThemePreference();
      
      // Automatically load saved data
      loadData(false);
      
      // Setup event listeners
      document.getElementById('themeToggle').addEventListener('click', toggleTheme);
      
      // Setup auto-save for all input fields
      setupAutoSave();
      
      // Apply animations
      document.querySelectorAll('.card').forEach(card => {
        card.style.opacity = '0';
        card.style.transform = 'translateY(20px)';
        setTimeout(() => {
          card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
          card.style.opacity = '1';
          card.style.transform = 'translateY(0)';
        }, 100);
      });
    });

    // UI Rendering Functions
    function renderIngredientsTable() {
      const tableContainer = document.getElementById('ingredients-table');
      let html = '<table><tr><th>Ingredient</th><th>Stock</th></tr>';
      
      ingredients.forEach(ing => {
        html += `
          <tr>
            <td>
              <div class="tooltip">
                ${ing}
                <span class="tooltip-text">Used in ${getIngredientRecipeCount(ing)} recipes</span>
              </div>
            </td>
            <td>
              <div class="input-group">
                <input type="number" id="stock_${ing}" value="0" min="0" onchange="validateInput(this)">
                <div class="increment-buttons">
                  <button class="increment-button" onclick="adjustValue('stock_${ing}', 1)"><i class="fas fa-plus"></i></button>
                  <button class="increment-button" onclick="adjustValue('stock_${ing}', -1)"><i class="fas fa-minus"></i></button>
                </div>
              </div>
            </td>
          </tr>`;
      });
      
      html += '</table>';
      tableContainer.innerHTML = html;
    }
    
    function getIngredientRecipeCount(ingredient) {
      return recipes.filter(recipe => 
        requirements[recipe.name][ingredient] !== undefined && 
        requirements[recipe.name][ingredient] > 0
      ).length;
    }

    function adjustValue(inputId, amount) {
      const input = document.getElementById(inputId);
      const currentValue = parseInt(input.value) || 0;
      input.value = Math.max(0, currentValue + amount);
      // Trigger change event for validation
      input.dispatchEvent(new Event('change'));
      // Trigger input event for auto-save
      input.dispatchEvent(new Event('input'));
    }

    function validateInput(input) {
      const value = parseInt(input.value);
      if (isNaN(value) || value < 0) {
        input.value = 0;
        showToast('Please enter a valid positive number.');
      }
      // Trigger auto-save after validation
      input.dispatchEvent(new Event('input'));
    }

    // Core Optimization Algorithm
    function optimize() {
      const processing = document.getElementById('processing');
      const optimizeBtn = document.getElementById('optimizeBtn');
      
      processing.style.display = 'block';
      optimizeBtn.disabled = true;
      
      setTimeout(() => {
        const start = performance.now();
        const stock = {};
        ingredients.forEach(ing => { 
          stock[ing] = parseInt(document.getElementById(`stock_${ing}`).value) || 0; 
        });

        let bestTotal = -1;
        let bestSolution = [];

        function search(idx, counts, remaining) {
          if (idx === recipes.length) {
            const total = counts.reduce((a, b) => a + b, 0);
            if (total > bestTotal) { 
              bestTotal = total; 
              bestSolution = counts.slice(); 
            }
            return;
          }
          
          const recipe = recipes[idx].name;
          let maxPossible = Infinity;
          
          for (const ing of ingredients) {
            const need = requirements[recipe][ing] || 0;
            if (need > 0) { 
              maxPossible = Math.min(maxPossible, Math.floor(remaining[ing] / need)); 
            }
          }
          
          if (maxPossible === Infinity) maxPossible = 0;

          for (let count = 0; count <= maxPossible; count++) {
            const newStock = { ...remaining };
            let feasible = true;
            
            for (const ing of ingredients) {
              const need = (requirements[recipe][ing] || 0) * count;
              if (need > newStock[ing]) { 
                feasible = false; 
                break; 
              }
              newStock[ing] -= need;
            }
            
            if (feasible) { 
              search(idx + 1, counts.concat(count), newStock); 
            }
          }
        }

        // Start the optimization
        search(0, [], stock);
        
        // Calculate ingredient usage
        const usageData = {};
        ingredients.forEach(ing => {
          const used = recipes.reduce((sum, r, i) => 
            sum + (requirements[r.name][ing] || 0) * bestSolution[i], 0);
          const leftover = stock[ing] - used;
          
          usageData[ing] = {
            used,
            stock: stock[ing],
            leftover
          };
        });

        const end = performance.now();
        const timeTaken = ((end - start) / 1000).toFixed(3);
        
        renderResults(bestSolution, bestTotal, usageData, timeTaken);
        processing.style.display = 'none';
        optimizeBtn.disabled = false;
      }, 50);
    }

    // Results Rendering
    function renderResults(solution, totalRecipes, usageData, timeTaken) {
      const resultsDiv = document.getElementById('results');
      
      if (totalRecipes <= 0) {
        resultsDiv.innerHTML = `
          <div class="card">
            <h3><i class="fas fa-exclamation-triangle"></i> No Recipes Possible</h3>
            <p>You don't have enough ingredients to make any recipes. Try adding more ingredients.</p>
            <div class="button-group">
              <button class="button button-primary" onclick="applyPreset('random')">
                <i class="fas fa-dice"></i> Try Random Values
              </button>
            </div>
          </div>`;
        return;
      }

      // Stats summary
      let html = `
        <div class="card">
          <h3><i class="fas fa-chart-pie"></i> Optimization Results</h3>
          
          <div class="stats">
            <div class="stat-card">
              <div><i class="fas fa-cubes"></i> Total Recipes</div>
              <div class="stat-value">${totalRecipes}</div>
            </div>
            <div class="stat-card">
              <div><i class="fas fa-layer-group"></i> Unique Recipes</div>
              <div class="stat-value">${solution.filter(count => count > 0).length}</div>
            </div>
            <div class="stat-card">
              <div><i class="fas fa-stopwatch"></i> Calculation Time</div>
              <div class="stat-value">${timeTaken}s</div>
            </div>
          </div>
          
          <h3><i class="fas fa-th-large"></i> Recipe Breakdown</h3>
          <div class="recipe-icons">`;
      
      // Recipe icons with counts
      recipes.forEach((recipe, i) => {
        const count = solution[i];
        html += `
          <div class="recipe-icon tooltip" ${count === 0 ? 'style="opacity: 0.5;"' : ''}>
            <span class="tooltip-text">${recipe.name}</span>
            <div class="recipe-icon-emoji">${recipe.emoji}</div>
            <div>${recipe.name.split(' ')[0]}</div>
            <div class="recipe-icon-count">${count}</div>
          </div>`;
      });
      
      html += `
          </div>
          
          <h3><i class="fas fa-list-ul"></i> Recipe Details</h3>
          <table>
            <tr>
              <th>Recipe</th>
              <th>Count</th>
              <th>Required Ingredients</th>
            </tr>`;
      
      recipes.forEach((recipe, i) => {
        const count = solution[i];
        if (count > 0) {
          const reqList = Object.entries(requirements[recipe.name])
            .map(([ing, amt]) => `${ing} <strong>(${amt * count})</strong>`)
            .join(', ');
            
          html += `
            <tr>
              <td>${recipe.emoji} ${recipe.name}</td>
              <td>${count}</td>
              <td>${reqList}</td>
            </tr>`;
        }
      });
      
      html += `</table>
        </div>
        
        <div class="card">
          <h3><i class="fas fa-boxes"></i> Ingredient Usage</h3>
          <table>
            <tr>
              <th>Ingredient</th>
              <th>Stock</th>
              <th>Used</th>
              <th>Leftover</th>
            </tr>`;
      
      ingredients.forEach(ing => {
        const data = usageData[ing];
        const leftoverClass = data.leftover > 0 ? 'bg-warning' : 'bg-success';
        const leftoverTitle = data.leftover > 0 ? 'Unused ingredients' : 'All used';
        const efficiencyPercent = data.stock > 0 ? Math.round((data.used / data.stock) * 100) : 0;
        
        html += `
          <tr>
            <td>${ing}</td>
            <td>${data.stock}</td>
            <td>${data.used}</td>
            <td>
              <span class="leftover-indicator ${leftoverClass}" title="${leftoverTitle}"></span>
              ${data.leftover} <small>(${efficiencyPercent}% used)</small>
            </td>
          </tr>`;
      });
      
      html += `
          </table>
          
          <div class="text-center" style="margin-top: 2rem">
            <p class="text-success"><i class="fas fa-check-circle"></i> Optimization completed in ${timeTaken} seconds</p>
            <div class="button-group" style="justify-content: center">
              <button class="button button-primary" onclick="optimize()">
                <i class="fas fa-sync-alt"></i> Recalculate
              </button>
              <button class="button button-secondary" onclick="exportData()">
                <i class="fas fa-file-export"></i> Export Results
              </button>
            </div>
          </div>
        </div>`;
      
      resultsDiv.innerHTML = html;
      
      // Scroll to results
      setTimeout(() => {
        resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 100);
    }

    // Data Management Functions
    function saveData(showNotification = true) {
      try {
        const data = {};
        ingredients.forEach(ing => data[ing] = document.getElementById(`stock_${ing}`).value);
        localStorage.setItem('cookie_optimizer_data', JSON.stringify(data));
        if (showNotification) {
          showToast('Data saved successfully!');
        }
        return true;
      } catch (error) {
        if (showNotification) {
          showToast('Failed to save data: ' + error.message, 'error');
        }
        console.error('Save error:', error);
        return false;
      }
    }

    function loadData(showNotification = true) {
      try {
        const data = JSON.parse(localStorage.getItem('cookie_optimizer_data') || '{}');
        let loadedCount = 0;
        
        ingredients.forEach(ing => { 
          if (data[ing] !== undefined) {
            document.getElementById(`stock_${ing}`).value = data[ing];
            loadedCount++;
          }
        });
        
        if (showNotification && loadedCount > 0) {
          showToast(`Loaded ${loadedCount} ingredient values from saved data.`);
        }
        return loadedCount;
      } catch (error) {
        if (showNotification) {
          showToast('Failed to load data: ' + error.message, 'error');
        }
        console.error('Load error:', error);
        return 0;
      }
    }

    function clearData() {
      try {
        localStorage.removeItem('cookie_optimizer_data');
        ingredients.forEach(ing => document.getElementById(`stock_${ing}`).value = 0);
        showToast('All values reset successfully.');
      } catch (error) {
        showToast('Failed to reset data: ' + error.message, 'error');
      }
    }
    
    // Set up auto-save functionality for all ingredient inputs
    function setupAutoSave() {
      let saveTimeout;
      let indicatorTimeout;
      const SAVE_DELAY = 800; // Wait time in ms after last change before saving
      const INDICATOR_DISPLAY_TIME = 1500; // How long to show the indicator
      const autoSaveIndicator = document.getElementById('autoSaveIndicator');
      
      ingredients.forEach(ing => {
        const inputElem = document.getElementById(`stock_${ing}`);
        
        // Save when input changes
        inputElem.addEventListener('input', () => {
          // Show auto-save indicator
          autoSaveIndicator.classList.add('show');
          
          // Clear previous timeouts
          if (saveTimeout) clearTimeout(saveTimeout);
          if (indicatorTimeout) clearTimeout(indicatorTimeout);
          
          // Set new timeout to save after delay
          saveTimeout = setTimeout(() => {
            saveData(false);
            
            // Hide indicator after a delay
            indicatorTimeout = setTimeout(() => {
              autoSaveIndicator.classList.remove('show');
            }, INDICATOR_DISPLAY_TIME);
            
          }, SAVE_DELAY);
        });
        
        // Also save on blur (when leaving the input)
        inputElem.addEventListener('blur', () => {
          if (saveTimeout) {
            clearTimeout(saveTimeout);
            saveData(false);
            
            // Show indicator briefly
            autoSaveIndicator.classList.add('show');
            if (indicatorTimeout) clearTimeout(indicatorTimeout);
            indicatorTimeout = setTimeout(() => {
              autoSaveIndicator.classList.remove('show');
            }, INDICATOR_DISPLAY_TIME);
          }
        });
      });
      
      // Also trigger auto-save when preset buttons are clicked
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setTimeout(() => {
            saveData(false);
            
            // Show indicator briefly
            autoSaveIndicator.classList.add('show');
            if (indicatorTimeout) clearTimeout(indicatorTimeout);
            indicatorTimeout = setTimeout(() => {
              autoSaveIndicator.classList.remove('show');
            }, INDICATOR_DISPLAY_TIME);
          }, 100);
        });
      });
    }

    function exportData() {
      try {
        const data = {};
        ingredients.forEach(ing => data[ing] = document.getElementById(`stock_${ing}`).value);
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        a.href = url;
        a.download = `aurora_prelude_${timestamp}.json`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 100);
      } catch (error) {
        showToast('Failed to export data: ' + error.message, 'error');
      }
    }

    function importData(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          let loadedCount = 0;
          
          ingredients.forEach(ing => { 
            if (data[ing] !== undefined) {
              document.getElementById(`stock_${ing}`).value = data[ing];
              loadedCount++;
            }
          });
          
          showToast(`Imported ${loadedCount} ingredient values from file.`);
          
          // Reset the file input so the same file can be selected again
          document.getElementById('importFile').value = '';
        } catch (error) {
          showToast('Failed to import data: ' + error.message, 'error');
        }
      };
      reader.onerror = () => showToast('Error reading file', 'error');
      reader.readAsText(file);
    }

    // Excel Paste Functions
    function togglePasteBox() {
      const card = document.getElementById('excelCard');
      const isHidden = window.getComputedStyle(card).display === 'none';
      
      if (isHidden) {
        card.style.display = 'block';
        setTimeout(() => document.getElementById('excelPaste').focus(), 100);
      } else {
        card.style.display = 'none';
      }
    }
    
    function closePasteArea() {
      document.getElementById('excelCard').style.display = 'none';
    }

    function parseExcelPaste() {
      const text = document.getElementById('excelPaste').value.trim();
      
      if (!text) { 
        showToast('No data pasted', 'warning');
        return; 
      }
      
      const rows = text.split(/\n|\r/).filter(r => r.trim().length > 0);
      let appliedCount = 0;
      
      if (rows.length === ingredients.length) {
        // Try processing as one number per line
        rows.forEach((val, i) => {
          const num = parseInt(val.trim());
          if (!isNaN(num)) {
            document.getElementById(`stock_${ingredients[i]}`).value = num;
            appliedCount++;
          }
        });
        
        if (appliedCount > 0) {
          showToast(`Applied ${appliedCount} values from paste.`);
          closePasteArea();
          return;
        }
      }
      
      // Try processing as name-value pairs
      appliedCount = 0;
      rows.forEach(r => {
        // Split on tab, comma, or multiple spaces
        const parts = r.split(/\t|,|\s{2,}/).map(p => p.trim()).filter(p => p);
        
        if (parts.length >= 2) {
          // Look for ingredient name at start of string
          let ingredientFound = false;
          
          for (const ing of ingredients) {
            if (r.trim().toLowerCase().startsWith(ing.toLowerCase())) {
              const valueStr = r.trim().substring(ing.length).trim();
              const value = parseInt(valueStr);
              
              if (!isNaN(value)) {
                document.getElementById(`stock_${ing}`).value = value;
                appliedCount++;
                ingredientFound = true;
              }
              break;
            }
          }
          
          // If no match by name prefix, try explicit parts
          if (!ingredientFound) {
            const ing = parts[0].trim();
            const val = parseInt(parts[1].trim());
            
            if (ingredients.includes(ing) && !isNaN(val)) {
              document.getElementById(`stock_${ing}`).value = val;
              appliedCount++;
            } else {
              // Try case-insensitive match
              const ingLower = ing.toLowerCase();
              const matchedIng = ingredients.find(i => i.toLowerCase() === ingLower);
              
              if (matchedIng && !isNaN(val)) {
                document.getElementById(`stock_${matchedIng}`).value = val;
                appliedCount++;
              }
            }
          }
        }
      });
      
      if (appliedCount > 0) {
        showToast(`Applied ${appliedCount} values from paste.`);
        closePasteArea();
      } else {
        showToast('Could not recognize the pasted data format.', 'error');
      }
    }

    // Utility Functions
    function showToast(message, type = 'success') {
      const toast = document.getElementById('toast');
      
      // Set class and icon based on type
      let icon = '';
      toast.className = 'toast show';
      
      if (type === 'error') {
        toast.className += ' error';
        icon = '<i class="fas fa-exclamation-circle toast-icon"></i>';
      } else if (type === 'warning') {
        toast.className += ' warning';
        icon = '<i class="fas fa-exclamation-triangle toast-icon"></i>';
      } else {
        toast.className += ' success';
        icon = '<i class="fas fa-check-circle toast-icon"></i>';
      }
      
      toast.innerHTML = `${icon} ${message}`;
      
      setTimeout(() => {
        toast.className = 'toast';
      }, 3500);
    }

    function toggleTheme() {
      document.body.classList.toggle('dark');
      const isDark = document.body.classList.contains('dark');
      const themeLabel = document.getElementById('themeLabel');
      const themeIcon = document.getElementById('themeToggle').querySelector('i');
      
      if (isDark) {
        themeLabel.textContent = 'Light Mode';
        themeIcon.className = 'fas fa-sun';
      } else {
        themeLabel.textContent = 'Dark Mode';
        themeIcon.className = 'fas fa-moon';
      }
      
      localStorage.setItem('cookieOptimizer_darkMode', isDark ? 'dark' : 'light');
    }

    function loadThemePreference() {
      const savedTheme = localStorage.getItem('cookieOptimizer_darkMode');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (savedTheme === 'dark' || (savedTheme === null && prefersDark)) {
        document.body.classList.add('dark');
        document.getElementById('themeLabel').textContent = 'Light Mode';
        document.querySelector('#themeToggle i').className = 'fas fa-sun';
      }
    }
    
    // Quick preset functions
    function applyPreset(type) {
      switch(type) {
        case 'clear':
          ingredients.forEach(ing => document.getElementById(`stock_${ing}`).value = 0);
          showToast('All ingredients cleared.');
          break;
        case 'random':
          ingredients.forEach(ing => {
            const randomVal = Math.floor(Math.random() * 20);
            document.getElementById(`stock_${ing}`).value = randomVal;
          });
          showToast('Random values applied.');
          break;
        case 'balanced':
          ingredients.forEach(ing => document.getElementById(`stock_${ing}`).value = 10);
          showToast('Balanced values applied (10 each).');
          break;
      }
    }
    
    // Modal functions
    function closeModal(modalId) {
      document.getElementById(modalId).classList.remove('show');
    }
    
    function openModal(modalId) {
      document.getElementById(modalId).classList.add('show');
    }
    
    // Open the suggestion modal
    function suggestIngredients() {
      // Clear previous results
      document.getElementById('suggestionResults').innerHTML = '';
      document.getElementById('suggestionResults').style.display = 'none';
      
      // Reset max ingredients to default
      document.getElementById('maxIngredients').value = 50;
      
      // Open the modal
      openModal('suggestionModal');
    }
    
    // Function to suggest optimal ingredients to request from teammates
    function calculateOptimalIngredientRequest() {
      // Get the maximum number of ingredients the user can request
      const maxIngredients = parseInt(document.getElementById('maxIngredients').value);
      if (isNaN(maxIngredients) || maxIngredients <= 0) {
        showToast("Please enter a valid number of ingredients", "error");
        return;
      }
      
      // Get current ingredient stock
      const currentStock = {};
      ingredients.forEach(ing => {
        const value = parseInt(document.getElementById(`stock_${ing}`).value) || 0;
        currentStock[ing] = value;
      });
      
      // Calculate optimal ingredients to request
      const suggestions = optimizeIngredientRequests(currentStock, maxIngredients);
      
      // Display the suggestions
      displayIngredientSuggestions(suggestions, currentStock);
    }
    
    function optimizeIngredientRequests(currentStock, maxIngredients) {
      // Use linear programming approach inspired by the Python solution
      // This is a much more efficient algorithm that considers the global optimum
      // rather than making greedy local decisions
      
      // First, analyze all recipes to determine the value of each ingredient
      const ingredientValue = calculateIngredientValues(requirements);
      
      // Create a copy of the current stock to work with
      const suggestedStock = {...currentStock};
      
      // Track how many additional ingredients we've allocated
      let additionalCount = 0;
      
      // Calculate how many of each recipe we can make with current stock
      const baseResult = calculateOptimalRecipes(currentStock);
      let bestImprovement = 0;
      
      // Use a more sophisticated approach that considers batches of ingredients
      // We'll try various combinations focusing on high-value ingredients first
      const batchSize = Math.min(10, maxIngredients);
      
      while (additionalCount < maxIngredients) {
        // Determine how many ingredients we can still add in this batch
        const currentBatchSize = Math.min(batchSize, maxIngredients - additionalCount);
        
        // Try different distributions of this batch across ingredients
        const distributions = generateDistributions(ingredients, currentBatchSize, ingredientValue);
        
        let bestDistribution = null;
        let bestDistributionResult = null;
        
        // Evaluate each distribution
        for (const distribution of distributions) {
          // Create a test stock with this distribution
          const testStock = {...suggestedStock};
          for (const [ing, amount] of Object.entries(distribution)) {
            testStock[ing] = (testStock[ing] || 0) + amount;
          }
          
          // Calculate recipes with this test stock
          const result = calculateOptimalRecipes(testStock);
          
          // Check if this is better than our current best
          if (!bestDistributionResult || result.totalRecipes > bestDistributionResult.totalRecipes) {
            bestDistribution = distribution;
            bestDistributionResult = result;
          }
        }
        
        // If we found a better distribution, apply it
        if (bestDistribution) {
          for (const [ing, amount] of Object.entries(bestDistribution)) {
            suggestedStock[ing] = (suggestedStock[ing] || 0) + amount;
            additionalCount += amount;
          }
          
          // If no improvement was made, break early
          const improvement = bestDistributionResult.totalRecipes - baseResult.totalRecipes;
          if (improvement <= bestImprovement) {
            break;
          }
          bestImprovement = improvement;
        } else {
          // No valid distribution found
          break;
        }
      }
      
      return suggestedStock;
    }
    
    // Calculate the relative value of each ingredient based on recipe requirements
    function calculateIngredientValues(recipeRequirements) {
      const values = {};
      
      // Count how many recipes use each ingredient
      for (const ingredient of ingredients) {
        let recipeCount = 0;
        let totalRequired = 0;
        
        for (const recipeName in recipeRequirements) {
          const amount = recipeRequirements[recipeName][ingredient] || 0;
          if (amount > 0) {
            recipeCount++;
            totalRequired += amount;
          }
        }
        
        // Value is based on recipe count and inverse of amount required
        // Higher recipe count means more versatile ingredient
        // Lower amount required means more efficient use
        values[ingredient] = recipeCount > 0 ? recipeCount / Math.sqrt(totalRequired) : 0;
      }
      
      return values;
    }
    
    // Generate different distributions of ingredients
    function generateDistributions(ingredientList, batchSize, valueMap) {
      const distributions = [];
      
      // Sort ingredients by their value (most valuable first)
      const sortedIngredients = [...ingredientList].sort((a, b) => 
        (valueMap[b] || 0) - (valueMap[a] || 0)
      );
      
      // Add focused distributions (all on one ingredient)
      for (const ing of sortedIngredients) {
        if (valueMap[ing] > 0) {
          const dist = {};
          dist[ing] = batchSize;
          distributions.push(dist);
        }
      }
      
      // Add balanced distribution among top ingredients
      const balancedDist = {};
      const topCount = Math.min(3, sortedIngredients.length);
      for (let i = 0; i < topCount; i++) {
        balancedDist[sortedIngredients[i]] = Math.floor(batchSize / topCount);
      }
      // Distribute any remainder
      let remainder = batchSize - (Math.floor(batchSize / topCount) * topCount);
      for (let i = 0; i < remainder; i++) {
        balancedDist[sortedIngredients[i]]++;
      }
      distributions.push(balancedDist);
      
      return distributions;
    }
    
    function calculateOptimalRecipes(ingredientStock) {
      // Clone the stock to work with
      const remainingStock = {...ingredientStock};
      
      // Initialize recipe counts
      const recipeCounts = {};
      recipes.forEach(recipe => {
        recipeCounts[recipe.name] = 0;
      });
      
      let changed = true;
      while (changed) {
        changed = false;
        
        // Try each recipe
        for (const recipe of recipes) {
          const name = recipe.name;
          const recipeReqs = requirements[name];
          
          // Check if we can make this recipe
          let canMake = true;
          for (const [ingredient, amount] of Object.entries(recipeReqs)) {
            if (!remainingStock[ingredient] || remainingStock[ingredient] < amount) {
              canMake = false;
              break;
            }
          }
          
          if (canMake) {
            // Make the recipe
            recipeCounts[name]++;
            
            // Deduct used ingredients
            for (const [ingredient, amount] of Object.entries(recipeReqs)) {
              remainingStock[ingredient] -= amount;
            }
            
            // Mark that we made a change
            changed = true;
            break;
          }
        }
      }
      
      // Calculate total recipes made
      const totalRecipes = Object.values(recipeCounts).reduce((sum, count) => sum + count, 0);
      
      return {
        recipeMix: recipeCounts,
        totalRecipes: totalRecipes,
        remainingStock: remainingStock
      };
    }
    
    function displayIngredientSuggestions(suggestedStock, currentStock) {
      // Calculate what ingredients to request (only the new ones)
      const toRequest = {};
      let totalRequestCount = 0;
      
      for (const [ingredient, amount] of Object.entries(suggestedStock)) {
        const currentAmount = currentStock[ingredient] || 0;
        if (amount > currentAmount) {
          toRequest[ingredient] = amount - currentAmount;
          totalRequestCount += amount - currentAmount;
        }
      }
      
      // Calculate results with current stock
      const currentResult = calculateOptimalRecipes(currentStock);
      
      // Calculate results with suggested stock
      const suggestedResult = calculateOptimalRecipes(suggestedStock);
      
      // Calculate improvement
      const improvement = suggestedResult.totalRecipes - currentResult.totalRecipes;
      
      // Create a summary of recipes
      const recipesDiff = {};
      for (const [recipe, suggestedCount] of Object.entries(suggestedResult.recipeMix)) {
        const currentCount = currentResult.recipeMix[recipe] || 0;
        if (suggestedCount > currentCount) {
          recipesDiff[recipe] = suggestedCount - currentCount;
        }
      }
      
      // Get the suggestion results element
      const suggestionResults = document.getElementById('suggestionResults');
      
      // Create the content
      let content = `
        <div class="suggestion-card">
          <div class="suggestion-intro">
            <h4>Suggested Ingredients to Request</h4>
            <p>Requesting these ${totalRequestCount} ingredients could help you make ${improvement} more recipes.</p>
          </div>`;
      
      if (improvement <= 0) {
        content += `<p>No improvements possible with the specified constraints.</p>`;
      } else {
        // Display ingredients to request
        content += `<h5>Ingredients to Request:</h5>
          <div class="suggestion-list">`;
        
        // Sort ingredients by amount (descending)
        const sortedRequests = Object.entries(toRequest)
          .sort((a, b) => b[1] - a[1]);
        
        sortedRequests.forEach(([ingredient, amount]) => {
          content += `
            <div class="suggestion-item">
              <span>${ingredient}</span>
              <span class="suggestion-amount">${amount}</span>
            </div>`;
        });
        
        content += `</div>`;
        
        // Display recipe improvements
        content += `<h5>Recipe Improvements:</h5>
          <div class="result-grid">`;
        
        // Sort recipes by improvement (descending)
        const sortedRecipes = Object.entries(recipesDiff)
          .sort((a, b) => b[1] - a[1]);
        
        sortedRecipes.forEach(([recipe, amount]) => {
          const emoji = recipes.find(r => r.name === recipe)?.emoji || '';
          content += `
            <div class="result-item">
              <div class="item-name">${emoji} ${recipe}</div>
              <div class="item-value">+${amount}</div>
            </div>`;
        });
        
        content += `</div>`;
      }
      
      // Add apply button
      content += `
        <div class="suggestion-actions">
          <button class="apply-suggestion" onclick="applyIngredientSuggestions()">
            <i class="fas fa-check"></i> Apply to Ingredients
          </button>
        </div>
      </div>`;
      
      // Set the content
      suggestionResults.innerHTML = content;
      suggestionResults.style.display = 'block';
    }
    
    function applyIngredientSuggestions() {
      // Get the maximum number of ingredients
      const maxIngredients = parseInt(document.getElementById('maxIngredients').value);
      
      // Get current ingredient stock
      const currentStock = {};
      ingredients.forEach(ing => {
        const value = parseInt(document.getElementById(`stock_${ing}`).value) || 0;
        currentStock[ing] = value;
      });
      
      // Calculate optimal suggestions
      const suggestions = optimizeIngredientRequests(currentStock, maxIngredients);
      
      // Apply the suggestions to the UI
      ingredients.forEach(ing => {
        if (suggestions[ing] !== undefined) {
          document.getElementById(`stock_${ing}`).value = suggestions[ing];
        }
      });
      
      // Close the modal
      closeModal('suggestionModal');
      
      // Show a success message
      showToast("Suggested ingredients applied to stock", "success");
      
      // Trigger auto-save
      saveData();
    }
  </script>
</body>
</html>
